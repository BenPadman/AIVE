# @File(label="Input Stack", description="Image to generate features for", style="file") InputImage
# @File(label="Output directory", description="Select the output directory", style="directory") FEAToutputDir
# @File(label="TEMPORARY STORAGE DIR", description="TEMP DIRECTORY", style="directory") tempDir
# @Integer(label="Additional target slices per loop", description="ChunkExpansion",value=1) SliceExpansionNumber
# @Integer(label="Starting Slice", description="StartSlice",value=1) StartSlice
/*
 * READ ME BEFORE RUNNING SCRIPT: 
 * Before proceeding, ensure the following is true:
 * 1) Your stack needs to be spatially registered/aligned. 
 * 2) Your stack needs to have the correct spatial scale set in FIJI [by selecting Image->Properties (Ctrl+Shift+P)]; Enter the correct X/Y scale and the Z-slice thickness.
 * 3) Your stack needs to be saved as a tif.
 * Generating features takes a long time, so heed these warnings.
 * 
 * Other notes:
 * You will need a "temporary" directory stored somewhere local, ideally on an SSD; this is where the partially computed features will be stored before they are combined.
 * If you run out of RAM space when you attempt to run this, reduce the number of "Additional target slices per loop"; if that doesnt work, get more RAM.
 * Certain features can be disabled in the section labelled ***DEFINE FEATURES FOR 3D ANALYSIS***, but be careful about enabling features that are already present in other loops.
 * 
 * This is the script written to generate 3D feature stacks for subsequent analysis in WEKA. 
 * The script massively reduces memory usage by only analysing the minimum number slices for each 3D operation.
 * Theoretically, this allows the analysis of infinitely long stacks, at the expense of wasted computation.
 * 
 * The Sigma value defines the maximum radius of the features generated by this script.
 * Edit the number directly below to use smaller or larger values:
 */
int SigmaValue=8;

import ij.*;
import ij.process.*;
import ij.plugin.filter.*;
import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.gui.Roi;
import ij.gui.PolygonRoi;
import ij.plugin.Duplicator;
import ij.process.FloatPolygon;
import ij.process.StackConverter;
import ij.io.*;
import ij.process.ColorSpaceConverter;
import ij.process.ByteProcessor;
import ij.io.FileSaver;
import trainableSegmentation.FeatureStack;
import trainableSegmentation.FeatureStackArray;
import trainableSegmentation.WekaSegmentation;
import trainableSegmentation.utils.Utils;
import ij.plugin.ImageCalculator; 


duplicator = new Duplicator();
InitialDecoyImage = IJ.createImage("Initial Decoy Image", "8-bit black", 512, 512, 1);
	wekaSegmentation = new WekaSegmentation(true);


void CallTheGarbos() { //An attempt to deal with inevitable memory leaks with Java
	IJ.run("Close All", "");
            result = null; 
            image = null;
            stack = null;
            AnalysisChunk = null;
            tempRename = null;
                        IJ.wait(100);
            System.gc(); /*WHY...*/
            IJ.wait(1000);
                        System.gc(); /*...WONT...*/
                        IJ.wait(1000);
                                    System.gc(); /*...YOU...*/
                                    IJ.wait(1000);
                                                System.gc(); /*...DIE?!!!*/
                                                IJ.wait(1000);
            IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(2000);/*Take a deep breath and move on*/
}

SlicesPerChunk=null;
void ChunkDefiner(file, Sigma) {
	CallTheGarbos();
imgpath=file.getCanonicalPath();
image = IJ.openVirtual(imgpath);
ImgTitle=image.title;
dim = image.getDimensions(); //width, height, channels, slices, frames
stackWidth = dim[ 0 ];
stackHeight = dim[ 1 ];
StackSlices = dim[ 3 ];
voxelWidth = image.getCalibration().pixelWidth;
voxelHeight = image.getCalibration().pixelHeight;
voxelDepth = image.getCalibration().pixelDepth;
voxelAR = voxelWidth/voxelDepth;
SlicesPerChunk=Math.ceil(voxelAR*Sigma);
            result = null; 
            image = null;
            System.gc();
}



void FeatureSliceExtractor(file, Sigma, ChunkRange, slice, sliceExpansion) {
//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.wait(200);
IJ.log("Clearing RAM");
//CLEAR THE RAM
IJ.wait(1000);/*Take a deep breath and move on*/

imgpath=file.getCanonicalPath();
image = new ImagePlus( file.getCanonicalPath() );
ImgTitle=image.getTitle().replace(".tif",""); 
dim = image.getDimensions(); //width, height, channels, slices, frames
stackWidth = dim[ 0 ];
stackHeight = dim[ 1 ];
StackSlices = dim[ 3 ];
FinalSlice = Math.round(StackSlices);
voxelWidth = image.getCalibration().pixelWidth;
voxelHeight = image.getCalibration().pixelHeight;
voxelDepth = image.getCalibration().pixelDepth;

    stack = new ImageStack( stackWidth, stackHeight ); //makes empty stack to collect the chunk slices
FullImageCalibration = image.getCalibration().copy();  

   wekaSegmentation.setMaximumSigma(Sigma);
   //***DEFINE FEATURES FOR 3D ANALYSIS***
   //This sub-division of features should delegate approximately 12 feature slices to each stack
enableFeatures1 = new boolean[]{
            false,   /* Gaussian_blur; featslices=1  */ 
            true,   /* Hessian; featslices=3*/ 
            true,   /* Derivatives; featslices=5*/
            false,   /* Laplacian; featslices=1*/
            false,   /* Structure; featslices=6*/
            false,  /* Edges; featslices=1 */
            false,  /* Difference Of Gaussians; featslices=SIGMA DEPENDENT (3)*/
            false,  /* Minimum; featslices=1*/
            false,  /* Maximum; featslices=1*/
            false,  /* Mean; featslices=1 */
            false,  /* Median; featslices=1 */
            false   /* Variance; featslices=1 */
};
enableFeatures2 = new boolean[]{
            false,   /* Gaussian_blur; featslices=1  */ 
            false,   /* Hessian; featslices=3*/ 
            false,   /* Derivatives; featslices=5*/
            true,   /* Laplacian; featslices=1*/
            true,   /* Structure; featslices=6*/
            true,  /* Edges; featslices=1 */	
            false,  /* Difference Of Gaussians; featslices=SIGMA DEPENDENT (3)*/
            false,  /* Minimum; featslices=1*/
            false,  /* Maximum; featslices=1*/
            false,  /* Mean; featslices=1 */
            false,  /* Median; featslices=1 */
            false   /* Variance; featslices=1 */
};
enableFeatures3 = new boolean[]{
            true,   /* Gaussian_blur; featslices=1  */ 
            false,   /* Hessian; featslices=3*/ 
            false,   /* Derivatives; featslices=5*/
            false,   /* Laplacian; featslices=1*/
            false,   /* Structure; featslices=6*/
            false,  /* Edges; featslices=1 */	
            true,  /* Difference Of Gaussians; featslices=SIGMA DEPENDENT (3)*/
            true,  /* Minimum; featslices=1*/
            true,  /* Maximum; featslices=1*/
            true,  /* Mean; featslices=1 */
            true,  /* Median; featslices=1 */
            true   /* Variance; featslices=1 */
};

/*
 * ***START OF CONDITIONAL CHUNKMAKER***
 * Condition 1 applies to slices near the start of the stack
 * Condition 2 applies to slices near the end of the stack
 * Condition 3 applies to all other slices (the middle of the stack)
 */
int ChunkStart = slice-ChunkRange;
int ChunkEnd = slice+ChunkRange+sliceExpansion;
if (ChunkStart < 2) {//***IF CHUNK IS NEAR START (Condition 1)
ChunkStart = 1;
	for (i=ChunkStart; i <= ChunkEnd; i++ ) {
sliceimage = image.getStack().getProcessor(i);
slicename = image.getStack().getShortSliceLabel(i);
stack.addSlice(slicename, sliceimage);
}
AnalysisChunk = new ImagePlus("stack", stack); 
	AnalysisChunk.setCalibration(FullImageCalibration);
	
				IJ.log("preparing featstackA");
							wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=1; i <= ChunkRange+1+sliceExpansion; i++ ) {	
	wekaSegmentation.setEnabledFeatures(enableFeatures1);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempA.tif");     
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.wait(200);
IJ.log("Clearing RAM");
//CLEAR THE RAM

		IJ.log("preparing featstackB");
					wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=1; i <= ChunkRange+1+sliceExpansion; i++ ) {
	wekaSegmentation.setEnabledFeatures(enableFeatures2);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempB.tif");     
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(2000);/*Take a deep breath and move on*/
IJ.log("Clearing RAM");
//CLEAR THE RAM

		IJ.log("preparing featstackC");
					wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=1; i <= ChunkRange+1+sliceExpansion; i++ ) {
	wekaSegmentation.setEnabledFeatures(enableFeatures3);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempC.tif");     
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.wait(2000);/*Take a deep breath and move on*/
IJ.log("Clearing RAM");
//CLEAR THE RAM

//MERGE THE FEATURE STACKS
		for (int j=1; j <= ChunkRange+1+sliceExpansion; j++ ) {
					IJ.log("Merging Feature Stacks");
tempRename1 = IJ.openImage(tempDir+File.separator+"tempA"+IJ.pad(j,4)+".tif");
tempRename2 = IJ.openVirtual(tempDir+File.separator+"tempB"+IJ.pad(j,4)+".tif");
tempRename2dims = tempRename2.getDimensions();
tempRename2slices = tempRename2dims[ 3 ];
stack1=tempRename1.getStack();
//stack2=tempRename2.getStack();

for ( i = 2; i <= tempRename2slices; i++ ) {
featureimage = tempRename2.getStack().getProcessor(i);
featurename = tempRename2.getStack().getShortSliceLabel(i);//***This is essential for finding and assigning the feature name
stack1.addSlice(featurename, featureimage);
}
IJ.wait(200);
FinalStack1 = new ImagePlus("stack", stack1);
 new FileSaver( FinalStack1 ).saveAsTiff( tempDir + File.separator + "TempAB_"+IJ.pad(j,4)+".tif" ); //saves the stack 
 tempRename1=null;
 tempRename2=null;
 stack1=null;
 FinalStack1=null;
System.gc();
System.gc();
IJ.freeMemory();
IJ.wait(1000);
 tempRename23 = IJ.openImage(tempDir+File.separator+"TempAB_"+IJ.pad(j,4)+".tif");
PartialStack1=tempRename23.getStack();
//   stack23=tempRename3.getStack();
tempRename3 = IJ.openVirtual(tempDir+File.separator+"tempC"+IJ.pad(j,4)+".tif");
tempRename3dims = tempRename3.getDimensions();
tempRename3slices = tempRename3dims[ 3 ];
	for ( k = 2; k <= tempRename3slices; k++ ) {
featureimage = tempRename3.getStack().getProcessor(k);
featurename = tempRename3.getStack().getShortSliceLabel(k);//***took me ages to work that out
PartialStack1.addSlice(featurename, featureimage);
}
IJ.wait(200);
FinalStack = new ImagePlus("stack", PartialStack1);
 new FileSaver( FinalStack ).saveAsTiff( FEAToutputDir + File.separator + ImgTitle + "_feats_"+IJ.pad(j,4)+".tif" ); //saves the stack   

 
		}
//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(2000);/*Take a deep breath and move on*/
IJ.log("Clearing RAM");
//CLEAR THE RAM

	}
//For chunks near end, expansion slice does not play a role.
if (ChunkEnd >= StackSlices) {//***IF CHUNK IS NEAR END (Condition 2)
	
int ChunkEnd = StackSlices;
	for (i=ChunkStart; i <= ChunkEnd; i++ ) {
sliceimage = image.getStack().getProcessor(i);
slicename = image.getStack().getShortSliceLabel(i);
stack.addSlice(slicename, sliceimage);
}
AnalysisChunk = new ImagePlus("stack", stack); 
	AnalysisChunk.setCalibration(FullImageCalibration);
		wekaSegmentation.setTrainingImage(AnalysisChunk);	
//wekaSegmentation.setEnabledFeatures(enableFeatures);
Chunkdim = AnalysisChunk.getDimensions(); //width, height, channels, slices, frames
ChunkEnd = Chunkdim[ 3 ];
int ExtendedRange=ChunkEnd;

		IJ.log("preparing featstackA");
					wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=ChunkRange+1; i <= ExtendedRange; i++ ) {	
	wekaSegmentation.setEnabledFeatures(enableFeatures1);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempA.tif"); 
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.wait(200);
IJ.log("Clearing RAM");
//CLEAR THE RAM

		IJ.log("preparing featstackB");
					wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=ChunkRange+1; i <= ExtendedRange; i++ ) {	
	wekaSegmentation.setEnabledFeatures(enableFeatures2);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempB.tif"); 
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(2000);/*Take a deep breath and move on*/
IJ.log("Clearing RAM");
//CLEAR THE RAM

		IJ.log("preparing featstackC");
					wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=ChunkRange+1; i <= ExtendedRange; i++ ) {	
	wekaSegmentation.setEnabledFeatures(enableFeatures3);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempC.tif");     
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.wait(200);
IJ.log("Clearing RAM");
//CLEAR THE RAM

for (int j=ChunkRange+1; j <= ExtendedRange; j++ ) {
					IJ.log("Merging Feature Stacks");
tempRename1 = IJ.openImage(tempDir+File.separator+"tempA"+IJ.pad(j,4)+".tif");
tempRename2 = IJ.openVirtual(tempDir+File.separator+"tempB"+IJ.pad(j,4)+".tif");
tempRename2dims = tempRename2.getDimensions();
tempRename2slices = tempRename2dims[ 3 ];
stack1=tempRename1.getStack();
//stack2=tempRename2.getStack();

for ( i = 2; i <= tempRename2slices; i++ ) {
featureimage = tempRename2.getStack().getProcessor(i);
featurename = tempRename2.getStack().getShortSliceLabel(i);//***took me FOREVER to work out how to get the damn slice label.
stack1.addSlice(featurename, featureimage);
}
IJ.wait(200);
FinalStack1 = new ImagePlus("stack", stack1);
 new FileSaver( FinalStack1 ).saveAsTiff( tempDir + File.separator + "TempAB_"+IJ.pad(j,4)+".tif" ); //saves the stack 
  tempRename1=null;
 tempRename2=null;
 stack1=null;
  FinalStack1=null;
System.gc();
System.gc();
IJ.freeMemory();
IJ.wait(1000);
 tempRename23 = IJ.openImage(tempDir+File.separator+"TempAB_"+IJ.pad(j,4)+".tif");
PartialStack1=tempRename23.getStack();
 
//   stack23=tempRename3.getStack();
tempRename3 = IJ.openVirtual(tempDir+File.separator+"tempC"+IJ.pad(j,4)+".tif");
tempRename3dims = tempRename3.getDimensions();
tempRename3slices = tempRename3dims[ 3 ];
	for ( k = 2; k <= tempRename3slices; k++ ) {
featureimage = tempRename3.getStack().getProcessor(k);
featurename = tempRename3.getStack().getShortSliceLabel(k);//***took me FOREVER to work out how to get the damn slice label.
PartialStack1.addSlice(featurename, featureimage);
}
IJ.wait(200);
FinalStack = new ImagePlus("stack", PartialStack1);
int ChunkNToStackN = ((j+slice)-(ChunkRange+1));
 new FileSaver( FinalStack ).saveAsTiff( FEAToutputDir + File.separator + ImgTitle + "_feats_"+IJ.pad(ChunkNToStackN,4)+".tif" ); //saves the stack  
		}
//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(2000);/*Take a deep breath and move on*/
IJ.log("Clearing RAM");
//CLEAR THE RAM
		


} else {//IF CHUNK IS at MIDDLE (Condition 3)
	for (i=ChunkStart; i <= ChunkEnd; i++ ) {
sliceimage = image.getStack().getProcessor(i);
slicename = image.getStack().getShortSliceLabel(i);
stack.addSlice(slicename, sliceimage);
}
AnalysisChunk = new ImagePlus("stack", stack); 
	AnalysisChunk.setCalibration(FullImageCalibration);
		wekaSegmentation.setTrainingImage(AnalysisChunk);	
int ExtendedRange=ChunkRange+1+sliceExpansion;

		IJ.log("preparing featstackA");
for (int i=ChunkRange+1; i <= ExtendedRange; i++ ) {
		wekaSegmentation.setEnabledFeatures(enableFeatures1);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempA.tif");
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.wait(200);
IJ.log("Clearing RAM");
//CLEAR THE RAM

		IJ.log("preparing featstackB");
					wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=ChunkRange+1; i <= ExtendedRange; i++ ) {	
	wekaSegmentation.setEnabledFeatures(enableFeatures2);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempB.tif"); 
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(2000);/*Take a deep breath and move on*/
IJ.log("Clearing RAM");
//CLEAR THE RAM

		IJ.log("preparing featstackC");
					wekaSegmentation.setTrainingImage(AnalysisChunk);	
for (int i=ChunkRange+1; i <= ExtendedRange; i++ ) {	
	wekaSegmentation.setEnabledFeatures(enableFeatures3);
wekaSegmentation.saveFeatureStack(i, tempDir+File.separator, "tempC.tif");     
}

//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.wait(200);
IJ.log("Clearing RAM");
//CLEAR THE RAM

for (int j=ChunkRange+1; j <= ExtendedRange; j++ ) {
					IJ.log("Merging Feature Stacks");
tempRename1 = IJ.openImage(tempDir+File.separator+"tempA"+IJ.pad(j,4)+".tif");
tempRename2 = IJ.openVirtual(tempDir+File.separator+"tempB"+IJ.pad(j,4)+".tif");
tempRename2dims = tempRename2.getDimensions();
tempRename2slices = tempRename2dims[ 3 ];
stack1=tempRename1.getStack();
//stack2=tempRename2.getStack();

for ( i = 2; i <= tempRename2slices; i++ ) {
featureimage = tempRename2.getStack().getProcessor(i);
featurename = tempRename2.getStack().getShortSliceLabel(i);//***took me FOREVER to work out how to get the damn slice label.
stack1.addSlice(featurename, featureimage);
}
IJ.wait(200);
FinalStack1 = new ImagePlus("stack", stack1);
 new FileSaver( FinalStack1 ).saveAsTiff( tempDir + File.separator + "TempAB_"+IJ.pad(j,4)+".tif" ); //saves the stack 
  tempRename1=null;
 tempRename2=null;
 stack1=null;
  FinalStack1=null;
System.gc();
System.gc();
IJ.freeMemory();
IJ.wait(1000);
 tempRename23 = IJ.openImage(tempDir+File.separator+"TempAB_"+IJ.pad(j,4)+".tif");
PartialStack1=tempRename23.getStack();
 
//   stack23=tempRename3.getStack();
tempRename3 = IJ.openVirtual(tempDir+File.separator+"tempC"+IJ.pad(j,4)+".tif");
tempRename3dims = tempRename3.getDimensions();
tempRename3slices = tempRename3dims[ 3 ];
	for ( k = 2; k <= tempRename3slices; k++ ) {
featureimage = tempRename3.getStack().getProcessor(k);
featurename = tempRename3.getStack().getShortSliceLabel(k);//***took me FOREVER to work out how to get the damn slice label.
PartialStack1.addSlice(featurename, featureimage);
}
IJ.wait(200);
FinalStack = new ImagePlus("stack", PartialStack1);
int ChunkNToStackN = ((j+slice)-(ChunkRange+1));
 new FileSaver( FinalStack ).saveAsTiff( FEAToutputDir + File.separator + ImgTitle + "_feats_"+IJ.pad(ChunkNToStackN,4)+".tif" ); //saves the stack
		}
//CLEAR THE RAM
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
System.gc(); 
IJ.wait(200);
IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(2000);/*Take a deep breath and move on*/
IJ.log("Clearing RAM");
//CLEAR THE RAM
}
                        IJ.wait(100);
            System.gc(); /*WHY...*/
            IJ.wait(100);
                        System.gc(); /*...WONT...*/
                        IJ.wait(100);
                                    System.gc(); /*...YOU...*/
                                    IJ.wait(100);
                                                System.gc(); /*...DIE?!!!*/
                                                IJ.wait(100);
            IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(200);/*Take a deep breath and move on*/
}



/*
 * ***WHOLE STACK FEATURE SLICER***
 * Loop statement to apply the CHUNKED FEATURE STACK MAKER to all appropriate slices in given stack
 * ignores slices that are included in condition 1 and condition 2
 * Loops condition 1 twice for some reason, and i cant seem to fix it...
 */

void StackFeatureSlicer(file, Sigma, ChunkRange, sliceExpansion, StartingSlice) {
//int StartAt = null;
//int EndAt = null;
//int Increment = null;
imgpath=file.getCanonicalPath();
image = new ImagePlus( file.getCanonicalPath() );
ImgTitle=image.getTitle().replace(".tif",""); 
dim = image.getDimensions(); //width, height, channels, slices, frames
stackWidth = dim[ 0 ];
stackHeight = dim[ 1 ];
StackSlices = dim[ 3 ];
FinalSlice = Math.round(StackSlices);
voxelWidth = image.getCalibration().pixelWidth;
voxelHeight = image.getCalibration().pixelHeight;
voxelDepth = image.getCalibration().pixelDepth;

//Execute first half of featstack; for start of stack 
if (StartSlice<ChunkRange+1) {
	int StartAt = ChunkRange+1;
	int EndAt = (StackSlices-(ChunkRange));
	int Increment = sliceExpansion+1;
	for (i=StartAt; i <= EndAt; i+=Increment ) {//instead of incrementing by 1, increments by slice expansion why wont this work?
	EndRangePrintable=i+SliceExpansionNumber;
		IJ.log("Featstacks for target slice:"+i+" to "+EndRangePrintable);
				IJ.log("Slices remaining: "+(StackSlices-i)+" of "+StackSlices);
								IterationEstimate=(EndAt-i)/Increment;
								IJ.log("Computation loops still remaining: "+IterationEstimate);
	FeatureSliceExtractor(InputImage, SigmaValue, SlicesPerChunk, i, sliceExpansion);
                        IJ.wait(100);
            System.gc(); /*WHY...*/
            IJ.wait(200);
                        System.gc(); /*...WONT...*/
                        IJ.wait(200);
                                    System.gc(); /*...YOU...*/
                                    IJ.wait(200);
                                                System.gc(); /*...DIE?!!!*/
                                                IJ.wait(200);
            IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(5000);/*Take a deep breath and move on*/
	} 
}

if (StartSlice>=ChunkRange+1) {
	int StartAt = StartingSlice;
	int EndAt = (StackSlices-(ChunkRange));
	int Increment = sliceExpansion+1;
for (i=StartAt; i <= EndAt; i+=Increment ) {//instead of incrementing by 1, increments by slice expansion why wont this work?
	EndRangePrintable=i+SliceExpansionNumber;
		IJ.log("Featstacks for target slice:"+i+" to "+EndRangePrintable);
				IJ.log("Slices remaining: "+(StackSlices-i)+" of "+StackSlices);
								IterationEstimate=(EndAt-i)/Increment;
								IJ.log("Computation loops still remaining: "+IterationEstimate);
	FeatureSliceExtractor(InputImage, SigmaValue, SlicesPerChunk, i, sliceExpansion);
                        IJ.wait(100);
            System.gc(); /*WHY...*/
            IJ.wait(200);
                        System.gc(); /*...WONT...*/
                        IJ.wait(200);
                                    System.gc(); /*...YOU...*/
                                    IJ.wait(200);
                                                System.gc(); /*...DIE?!!!*/
                                                IJ.wait(200);
            IJ.freeMemory();
IJ.run("Reset...", "reset=Clipboard");
IJ.run("Reset...", "reset=[Undo Buffer]");
IJ.wait(5000);/*Take a deep breath and move on*/
	}
}
}


//RUN SCRIPT
ChunkDefiner(InputImage, SigmaValue);
//StartSlice
StackFeatureSlicer(InputImage, SigmaValue, SlicesPerChunk, SliceExpansionNumber,StartSlice);
